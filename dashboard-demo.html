<!--
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js" integrity="sha512-EmNxF3E6bM0Xg1zvmkeYD3HDBeGxtsG92IxFt1myNZhXdCav9MzvuH/zNMBU1DmIPN6njrhX1VTbqdJxQ2wHDg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style type="text/css">
    body {
      font-family: 'Roboto', serif;
    }

    #metrics {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
    }

    .metric {
      border: 1px solid #999;
      margin: 1px 2px 4px 2px;

      .chart { margin: 0; }
    }

    .label {
      height: 14px;
      padding-top: 2px;
      border-bottom: 1px solid #999;
      text-align: center;
      font-weight: bold;
      font-size: 10px;
      background-color: #eee;
    }

    table { border-collapse: collapse; width: 100%; font-size: 10px; }
    td, th { padding: 3px 5px; max-width: 700px; overflow-wrap: break-word; }
    th:not(:last-child), td:not(:last-child) { border-right: 1px solid #999; }
    tr:nth-child(even) { background-color: #f2f2f2; }
    tr:hover { background-color: #ddd; }
  </style>
</head>
<body>
  <div id="refreshTime"></div>
  <div id="metrics"></div>

  <script type="module">
    const demoTheme = {
      color: [
        '#5E93FF', // Series color 1
        '#67CC90', // Series color 2
        '#FFA663', // Series color 3
        '#6C7CFF', // Series color 4
        '#FF7A6A', // Series color 5
        '#7FABF7', // Series color 6
        '#FFBE53', // Series color 7
        '#8C96A1', // Series color 8
        '#69707A', // Series color 9
        '#8EB33B', // Series color 10
      ],
      backgroundColor: 'rgba(255, 255, 255, 0.95)',
      textStyle: { color: '#333' },
      title: { textStyle: { color: '#333' } },
      legend: { textStyle: { color: '#666' }, },
      tooltip: { axisPointer: { lineStyle: { color: '#666' }, crossStyle: { color: '#666' } }, },
      axisPointer: { lineStyle: { color: '#666' }, crossStyle: { color: '#666' } },
      toolbox: { iconStyle: { borderColor: '#666' } },
      dataZoom: { borderColor: 'rgba(102, 102, 102, 0.3)', dataBackground: { color: 'rgba(255, 255, 255, 0.1)' }, fillerColor: 'rgba(128, 128, 128, 0.2)' },
      timeline: { lineStyle: { color: '#666' }, itemStyle: { color: '#5E93FF' }, controlStyle: { normal: { color: '#666' } } },
    };

    echarts.registerTheme('demoTheme', demoTheme);
    const charts = {};

    function newChart(name, label, options) {
      let chart = charts[name];
      if (chart) {
        chart.setOption(options);
        return;
      }

      const node = document.createElement("div");
      node.className = "metric";
      node.id = name;

      const nodeLabel = document.createElement("div");
      nodeLabel.className = "label";
      nodeLabel.innerText = label;
      node.appendChild(nodeLabel);

      const nodeChart = document.createElement("div");
      nodeChart.className = "chart";
      nodeChart.style = "width: 490px; height: 185px;";
      node.appendChild(nodeChart);

      chart = echarts.init(nodeChart, 'demoTheme');
      chart.setOption(options);
      window.addEventListener('resize', function() { chart.resize(); });
      charts[name] = chart;

      document.getElementById("metrics").append(node);
    }

    function buildDateTimeLabels(lastInterval, window, count) {
      const items = [];
      const firstTs = lastInterval - (window * count);
      for (let i = 0; i < count; i++) {
        const d = new Date(firstTs + (i * window));
        const m = d.getMinutes();
        items.push(d.getHours() + ':' + (m > 10 ? m : '0' + m));
      }
      return items;
    }

    function renderTimeRangeCounter(metric) {
      const metricData = metric.data;
      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 50, top: 15, right: 10, bottom: 42 },
        xAxis: {
          type: 'category',
          axisLabel: { fontSize: 8 },
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          data: buildDateTimeLabels(metricData.lastInterval, metricData.window, metricData.counters.length),
        },
        yAxis: {
          type: 'value',
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          axisLabel: { fontSize: 8, formatter: (value) => humanConverter(value) },
        },
        tooltip: {
          trigger: 'axis',
          confine: true,
          position: 'inside',
          axisPointer: { type: 'shadow' },
          formatter: (data) => {
            let text = metric.label + '<br>';
            text += new Date(metricData.lastInterval - ((metricData.counters.length - data[0].dataIndex) * metricData.window)).toLocaleString();
            for (let i = 0; i < data.length; ++i) {
              const v = data[i];
              text += '<br>' + v.marker + v.seriesName + ": " + humanConverter(v.value);
            }
            return text;
          }
        },
        dataZoom: [{ show: true, realtime: true, height: 14, bottom: 10, textStyle: { fontSize: 8 } }],
        series: [
          { type: 'bar', name: metric.name, data: metricData.counters }
        ]
      });
    }

    function renderMaxAvgTimeRangeGauge(metric) {
      const metricData = metric.data;
      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 50, top: 15, right: 10, bottom: 42 },
        xAxis: {
          type: 'category',
          axisLabel: { fontSize: 8 },
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          data: buildDateTimeLabels(metricData.lastInterval, metricData.window, metricData.count.length)
        },
        yAxis: {
          type: 'value',
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          axisLabel: { fontSize: 8, formatter: (value) => humanConverter(value) }
        },
        tooltip: {
          trigger: 'axis',
          confine: true,
          position: 'inside',
          axisPointer: { type: 'shadow' },
          formatter: (data) => {
            let text = metric.label + '<br>';
            text += new Date(metricData.lastInterval - ((metricData.count.length - data[0].dataIndex) * metricData.window)).toLocaleString();
            for (let i = 0; i < data.length; ++i) {
              const v = data[i];
              text += '<br>' + v.marker + v.seriesName + ": " + humanConverter(v.value);
            }
            return text;
          }
        },
        dataZoom: [{ show: true, realtime: true, height: 14, bottom: 10, textStyle: { fontSize: 8 } }],
        series: [
          {
            name: 'max',
            type: 'line',
            itemStyle: {},
            areaStyle: {},
            lineStyle: { width: 1 },
            emphasis: { focus: 'series' },
            showSymbol: false,
            data: metricData.max
          },
          {
            name: 'avg',
            type: 'line',
            itemStyle: {},
            areaStyle: {},
            lineStyle: { width: 1 },
            emphasis: { focus: 'series' },
            showSymbol: false,
            data: metricData.count.map((v, index) => (v > 0) ? (metricData.sum[index] / v) : 0)
          },
        ]
      });
    }

    function renderHistogram(metric) {
      const metricData = metric.data;
      if (!metricData.bounds || metricData.bounds.length == 0) {
        console.debug('no data for metric', metric.name);
        return;
      }

      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      const bounds = metricData.bounds.map(v => humanConverter(v));
      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 50, top: 20, right: 15, bottom: 20 },
        xAxis: {
          type: 'category',
          axisLabel: { fontSize: 8 },
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          data: bounds
        },
        yAxis: {
          type: 'value',
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          axisLabel: { fontSize: 8, formatter: (value) => humanCount(value) }
        },
        tooltip: {
          trigger: 'axis',
          confine: true,
          position: 'inside',
          axisPointer: { type: 'shadow' },
          formatter: (data) => {
            let text = metric.label + '<br>';
            text += humanConverter(metricData.bounds[data[0].dataIndex]);
            for (let i = 0; i < data.length; ++i) {
              const v = data[i];
              text += '<br>' + v.marker + v.seriesName + ": " + humanCount(v.value);
            }
            return text;
          }
        },
        series: [
          { type: 'bar', name: metric.name, data: metricData.events }
        ]
      });
    }

    function renderHeatmap(metric) {
      // { lastInterval, window, bounds, events: [...] }
      const metricData = metric.data;
      if (!metricData.bounds || metricData.bounds.length == 0) {
        console.debug('no data for metric', metric.name);
        return;
      }

      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      const bounds = metricData.bounds.map(v => humanConverter(v));

      let maxEvents = 0;
      const data = [];
      const events = metricData.events;
      const numIntervals = events.length / bounds.length;
      for (let i = 0; i < events.length; ++i) {
        const x = Math.trunc(i / bounds.length);
        const y = i % bounds.length;
        data.push([x, y, events[i] || '-']);
        maxEvents = Math.max(maxEvents, events[i] || 0);
      }

      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 50, top: 5, right: 5, bottom: 40 },
        tooltip: {
          confine: true,
          position: 'inside',
          formatter: (data) => {
            const dateText = new Date(metricData.lastInterval - ((numIntervals - data.value[0]) * metricData.window)).toLocaleString();
            return metric.label + ': ' + dateText + '<br>' + bounds[data.value[1]] + ': <b>' + humanCount(data.value[2]) + '</b>';
          }
        },
        xAxis: {
          type: 'category',
          data: buildDateTimeLabels(metricData.lastInterval, metricData.window, numIntervals),
          axisLabel: { fontSize: 8 },
          splitArea: { show: true }
        },
        yAxis: {
          type: 'category',
          data: bounds,
          axisLabel: { fontSize: 8 },
          splitArea: { show: true }
        },
        visualMap: {
          formatter: (a, b) => humanCount(a) + '-' + humanCount(b),
          textStyle: { fontSize: 8 },
          type: 'piecewise',
          orient: 'horizontal',
          left: 'center',
          min: 0,
          max: maxEvents,
          calculable: true,
          itemGap: 8,
          textGap: 3,
          bottom: 0,
        },
        series: [
          {
            name: metric.label,
            type: 'heatmap',
            data: data,
            label: { show: true, fontSize: 5, formatter: v => humanCount(v.value[2]) },
            itemStyle: { borderWidth: 0.5, borderColor: '#888' },
            emphasis: {
              itemStyle: {
                borderColor: '#333',
                borderWidth: 1,
                shadowBlur: 10,
                shadowColor: 'rgba(0, 0, 0, 0.5)'
              }
            }
          }
        ]
      });
    }

    function renderTopK(metric) {
      const metricData = metric.data;
      if (!metricData.entries || metricData.entries.length == 0) {
        console.debug('no data for metric', metric.name);
        return;
      }

      let node = document.getElementById(metricKey(metric));
      if (node) {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }
      } else {
        node = document.createElement("div");
        node.className = "metric";
        node.id = metricKey(metric);
        document.getElementById("metrics").append(node);
      }

      const nodeTable = document.createElement("table");
      node.appendChild(nodeTable);

      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      const columnNames = [metric.label, 'Max Timestamp', 'Max', 'Min', 'Avg', 'StdDev', 'Freq', 'Sum'];
      const columnKeys = {
        'key': (row, k) => k.replaceAll('\n', ' '),
        'maxTimestamp': (row, t) => new Date(t).toLocaleString(),
        'maxValue': (row, v) => humanConverter(v),
        'minValue': (row, v) => humanConverter(v),
        'avg': (row, v) => humanConverter(Math.round(row['sum'] / row['count'])),
        'stdDev': (row, v) => {
          const variance = (row.sumSquares * row.count - row.sum * row.sum) / (row.count * row.count);
          const stdDev = Math.sqrt(Math.max(variance, 0.0));
          return humanConverter(Math.round(stdDev));
        },
        'count': (row, v) => humanCount(v),
        'sum': (row, v) => humanConverter(v),
      };
      const nodeHeader = document.createElement("tr");
      nodeTable.append(nodeHeader);
      for (const column of columnNames) {
        const nodeTh = document.createElement("th");
        nodeTh.className = 'label';
        nodeTh.innerText = column;
        nodeHeader.appendChild(nodeTh);
      }
      for (const row of metric.data.entries) {
        const nodeRow = document.createElement("tr");
        nodeTable.append(nodeRow);

        for (const key in columnKeys) {
          const keyConverter = columnKeys[key];
          let nodeTh = document.createElement("td");
          nodeTh.innerText = keyConverter(row, row[key]);
          nodeRow.appendChild(nodeTh);
        }
      }
    }

    function renderCounter(metric) {
      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 0, top: 0, right: 0, bottom: 0 },
        tooltip: {
          confine: true,
          position: 'inside',
          formatter: '{a} <br/>{b} : {c}'
        },
        series: [
          {
            name: metric.label,
            type: 'gauge',
            detail: {
              valueAnimation: true,
              fontSize: 12,
              offsetCenter: [0, '70%'],
              formatter: value => humanConverter(value)
            },
            progress: { show: true, width: 2 },
            axisLine: { lineStyle: { width: 2 } },
            axisTick: { show: false },
            splitLine: { length: 5, lineStyle: { width: 1, color: '#999' } },
            axisLabel: { distance: 6, fontSize: 8, color: '#999' },
            anchor: { show: true, showAbove: true, size: 10, itemStyle: { borderWidth: 2 } },
            title: { show: false },
            data: [ { value: metric.data.value, name: metric.name } ]
          }
        ]
      });
    }

    function renderCounterMap(metric) {
      const metricData = metric.data;
      if (!metricData.keys || metricData.keys.length == 0) {
        console.debug('no data for metric', metric.name);
        return;
      }

      const keys = metricData.keys.slice(0, 32);
      const vals = metricData.values.slice(0, 32);

      const humanConverter = METRIC_UNIT_CONVERTER[metric.unit];
      newChart(metricKey(metric), metric.label, {
        animation: false,
        grid: { left: 50, top: 20, right: 15, bottom: 10 },
        xAxis: {
          type: 'category',
          axisLabel: { show: false, fontSize: 8 },
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          data: keys,
        },
        yAxis: {
          type: 'value',
          splitLine: { show: true, lineStyle: { type: 'dashed' } },
          axisLabel: { fontSize: 8, formatter: (value) => humanCount(value) }
        },
        tooltip: {
          trigger: 'axis',
          confine: true,
          position: 'inside',
          axisPointer: { type: 'shadow' },
          formatter: (data) => {
            const v = data[0];
            let text = metric.label + '<br>';
            text += v.name + ': ' + humanConverter(v.data);
            return text;
          }
        },
        series: [{
          name: metric.name,
          type: 'bar',
          data: vals,
          label: {
            show: true,
            position: 'insideBottom',
            distance: 2,
            align: 'left',
            verticalAlign: 'middle',
            rotate: 90,
            formatter: '{name|{b}}',
            fontSize: 8,
            rich: { name: { fontSize: 8 } }
          }
        }]
      });
    }

    function humanBytes(size) {
      if (size >= 1099511627776) return (size / 1099511627776).toFixed(2) + 'TiB';
      if (size >= 1073741824) return (size / 1073741824).toFixed(2) + 'GiB';
      if (size >= 1048576) return (size / 1048576).toFixed(2) + 'MiB';
      if (size >= 1024) return (size / 1024).toFixed(2) + 'KiB';
      return (size > 0) ? Math.round(size) + 'bytes' : '0';
    }

    function humanCount(count) {
      if (count >= 1000000) return (count / 1000000).toFixed(2) + 'M';
      if (count >= 1000) return (count / 1000).toFixed(2) + 'K';
      return Math.round(count).toString()
    }

    function humanMillis(msec) {
      if (msec < 1000) {
        return Math.round(msec) + "ms";
      }

      const hours = Math.floor(msec / (60 * 60 * 1000));
      let rem = (msec % (60 * 60 * 1000));
      const minutes = Math.floor(rem / (60 * 1000));
      rem = rem % (60 * 1000);
      const seconds = rem / 1000.0;

      if ((hours > 0) || (minutes > 0)) {
        const buf = [];
        if (hours > 0) {
          buf.push(hours.toFixed(0));
          buf.push("hrs, ");
        }
        if (minutes > 0) {
          buf.push(minutes.toFixed(0));
          buf.push("min, ");
        }

        let humanTime;
        if (seconds > 0) {
          buf.push(seconds.toFixed(2));
          buf.push("sec");
          humanTime = buf.join('');
        } else {
          const sbuf = buf.join('');
          humanTime = sbuf.substring(0, sbuf.length - 2);
        }

        if (hours > 24) {
          const ndays = (hours / 24.0).toFixed(1);
          return `${humanTime} (${ndays} days)`;
        }
        return humanTime;
      }

      return ((seconds % 1) != 0 ? seconds.toFixed(2) : seconds.toFixed(0)) + 'sec';
    }

    const METRIC_UNIT_CONVERTER = {
      'BYTES': humanBytes,
      'COUNT': humanCount,
      'MILLISECONDS': humanMillis,
      'NANOSECONDS': v => humanMillis(v / 1000000),
      'PERCENT': v => v + '%',
    };

    const METRIC_RENDERERS = {
      'TIME_RANGE_COUNTER': renderTimeRangeCounter,
      'MAX_AVG_TIME_RANGE_GAUGE': renderMaxAvgTimeRangeGauge,
      'HISTOGRAM': renderHistogram,
      'HEATMAP': renderHeatmap,
      'TOPK': renderTopK,
      'COUNTER': renderCounter,
      'COUNTER_MAP': renderCounterMap,
    };

    function metricKey(metric) {
      let metric_key = metric.name;
      const dimensions = metric.dimensions;
      if (dimensions) {
        for (const key of Object.keys(dimensions).sort()) {
          const val = dimensions[key];
          metric_key += '/' + key + '/' + val;
        }
      }
      return metric_key;
    }

    async function fetchMetrics(jsonMetricsUrl) {
      const response = await fetch(jsonMetricsUrl);
      const metrics = await response.json();
      document.getElementById("refreshTime").innerText = new Date().toLocaleString();
      for (const metric of metrics.sort((a, b) => a.name.localeCompare(b.name))) {
        const renderer = METRIC_RENDERERS[metric.type];
        //console.log(metric);
        if (renderer) {
          renderer(metric);
        } else {
          console.log('unsupported metric type', metric.type, metric);
        }
      }
    }

    const JSON_METRICS_URL = 'http://localhost:57025/metrics/json';
    fetchMetrics(JSON_METRICS_URL);
    setInterval(async () => await fetchMetrics(JSON_METRICS_URL), 15_000);
  </script>
</body>
</html>
